import { __assign, __extends } from "tslib";
import { get } from '@antv/util';
import { FIELD_ORIGIN } from '../constant';
import Geometry from './base';
import Element from './element';
/** 引入对应的 ShapeFactory */
import './shape/line';
import { isModelChange } from './util/is-model-change';
/**
 * Path 几何标记。
 * 用于绘制路径图等。
 */
var Path = /** @class */ (function (_super) {
    __extends(Path, _super);
    function Path(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.type = 'path';
        _this.shapeType = 'line';
        var _a = cfg.connectNulls, connectNulls = _a === void 0 ? false : _a;
        _this.connectNulls = connectNulls;
        return _this;
    }
    /**
     * 创建所有的 Element 实例，对于 Path、Line、Area，一组数据对应一个 Element。
     * @param mappingData
     * @param [isUpdate]
     * @returns elements
     */
    Path.prototype.createElements = function (mappingData, isUpdate) {
        if (isUpdate === void 0) { isUpdate = false; }
        // Path 的每个 element 对应一组数据
        var _a = this, lastElementsMap = _a.lastElementsMap, elementsMap = _a.elementsMap, elements = _a.elements, theme = _a.theme, container = _a.container;
        var elementId = this.getElementId(mappingData);
        var shapeCfg = this.getShapeInfo(mappingData);
        var result = lastElementsMap[elementId] || elementsMap[elementId];
        if (!result) {
            var shapeFactory = this.getShapeFactory();
            result = new Element({
                theme: get(theme, ['geometries', this.shapeType], {}),
                shapeFactory: shapeFactory,
                container: container,
                offscreenGroup: this.getOffscreenGroup(),
            });
            result.geometry = this;
            result.draw(shapeCfg, isUpdate); // 绘制 shape
        }
        else {
            // element 已经创建
            var preShapeCfg = result.getModel();
            if (isModelChange(preShapeCfg, shapeCfg)) {
                // 通过绘制数据的变更来判断是否需要更新，因为用户有可能会修改图形属性映射
                result.update(shapeCfg); // 更新对应的 element
            }
            delete lastElementsMap[elementId];
        }
        if (!elementsMap[elementId]) {
            elements.push(result);
            elementsMap[elementId] = result;
        }
        return elements;
    };
    /**
     * 获取组成一条线（一组数据）的所有点数据。
     * @param mappingData
     * @returns points
     */
    Path.prototype.getPoints = function (mappingData) {
        return mappingData.map(function (obj) {
            return {
                x: obj.x,
                y: obj.y,
            };
        });
    };
    Path.prototype.getShapeInfo = function (mappingData) {
        var shapeCfg = this.getDrawCfg(mappingData[0]);
        return __assign(__assign({}, shapeCfg), { mappingData: mappingData, data: this.getData(mappingData), isStack: !!this.getAdjust('stack'), points: this.getPoints(mappingData), connectNulls: this.connectNulls });
    };
    Path.prototype.getData = function (mappingData) {
        return mappingData.map(function (obj) {
            return obj[FIELD_ORIGIN];
        });
    };
    return Path;
}(Geometry));
export default Path;
//# sourceMappingURL=path.js.map