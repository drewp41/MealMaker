import { __assign } from "tslib";
import { deepMix, each, get, isArray, isFunction, isNil, isNumber, isUndefined } from '@antv/util';
import { FIELD_ORIGIN } from '../../constant';
import { getPolygonCentroid } from '../../util/graphics';
function avg(arr) {
    var sum = 0;
    each(arr, function (value) {
        sum += value;
    });
    return sum / arr.length;
}
/**
 * Geometry Label 基类，用于解析 Geometry 下所有 label 的配置项信息
 */
var GeometryLabel = /** @class */ (function () {
    function GeometryLabel(geometry) {
        this.geometry = geometry;
        this.coordinate = geometry.coordinate;
        this.defaultLabelCfg = get(geometry.theme, 'labels', {}); // 默认样式
    }
    /**
     * 根据当前 shape 对应的映射数据获取对应的 label 配置信息。
     * @param mapppingArray 映射后的绘制数据
     * @returns
     */
    GeometryLabel.prototype.getLabelItems = function (mapppingArray) {
        var items = this.adjustItems(this.getItems(mapppingArray));
        this.drawLines(items);
        return items;
    };
    /**
     * 设置 label 位置
     * @param labelPointCfg
     * @param mappingData
     * @param index
     * @param position
     */
    GeometryLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) { };
    /**
     * 生成文本线配置
     * @param item
     */
    GeometryLabel.prototype.lineToLabel = function (item) { };
    /**
     * 调整 labels
     * @param items
     * @returns
     */
    GeometryLabel.prototype.adjustItems = function (items) {
        each(items, function (item) {
            if (!item) {
                return;
            }
            if (item.offsetX) {
                item.x += item.offsetX;
            }
            if (item.offsetY) {
                item.y += item.offsetY;
            }
        });
        return items;
    };
    /**
     * 绘制文本线
     * @param items
     */
    GeometryLabel.prototype.drawLines = function (items) {
        var _this = this;
        each(items, function (item) {
            if (!item) {
                return;
            }
            if (item.offset <= 0) {
                // 内部文本不绘制 labelLine
                item.labelLine = null;
            }
            if (item.labelLine) {
                _this.lineToLabel(item);
            }
        });
    };
    /**
     * 获取文本默认偏移量
     * @param offset
     * @returns
     */
    GeometryLabel.prototype.getDefaultOffset = function (offset) {
        var coordinate = this.coordinate;
        var vector = this.getOffsetVector(offset);
        return coordinate.isTransposed ? vector[0] : vector[1];
    };
    /**
     * 获取每个 label 的偏移量
     * @param labelCfg
     * @param index
     * @param total
     * @returns
     */
    GeometryLabel.prototype.getLabelOffset = function (labelCfg, index, total) {
        var offset = this.getDefaultOffset(labelCfg.offset);
        var coordinate = this.coordinate;
        var transposed = coordinate.isTransposed;
        var dim = transposed ? 'x' : 'y';
        var factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成
        var offsetPoint = {
            x: 0,
            y: 0,
        };
        if (index > 0 || total === 1) {
            // 判断是否小于0
            offsetPoint[dim] = offset * factor;
        }
        else {
            offsetPoint[dim] = offset * factor * -1;
        }
        return offsetPoint;
    };
    /**
     * 获取每个 label 的位置
     * @param labelCfg
     * @param mappingData
     * @param index
     * @returns label point
     */
    GeometryLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {
        var coordinate = this.coordinate;
        var total = labelCfg.content.length;
        function getDimValue(value, idx) {
            var v = value;
            if (isArray(v)) {
                if (labelCfg.content.length === 1) {
                    // 如果仅一个 label，多个 y, 取最后一个 y
                    if (v.length <= 2) {
                        v = v[value.length - 1];
                    }
                    else {
                        v = avg(v);
                    }
                }
                else {
                    v = v[idx];
                }
            }
            return v;
        }
        var label = {
            content: labelCfg.content[index],
            x: 0,
            y: 0,
            start: { x: 0, y: 0 },
            color: '#fff',
        };
        // 多边形场景，多用于地图
        if (mappingData && this.geometry.type === 'polygon') {
            var centroid = getPolygonCentroid(mappingData.x, mappingData.y);
            label.x = centroid[0];
            label.y = centroid[1];
        }
        else {
            label.x = getDimValue(mappingData.x, index);
            label.y = getDimValue(mappingData.y, index);
        }
        // get nearest point of the shape as the label line start point
        if (mappingData &&
            mappingData.nextPoints &&
            ['funnel', 'pyramid'].includes(isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape)) {
            var maxX_1 = -Infinity;
            mappingData.nextPoints.forEach(function (p) {
                var p1 = coordinate.convert(p);
                if (p1.x > maxX_1) {
                    maxX_1 = p1.x;
                }
            });
            label.x = (label.x + maxX_1) / 2;
        }
        // sharp edge of the pyramid
        if (mappingData.shape === 'pyramid' && !mappingData.nextPoints && mappingData.points) {
            mappingData.points.forEach(function (p) {
                var p1 = p;
                p1 = coordinate.convert(p1);
                if ((isArray(p1.x) && mappingData.x.indexOf(p1.x) === -1) ||
                    (isNumber(p1.x) && mappingData.x !== p1.x)) {
                    label.x = (label.x + p1.x) / 2;
                }
            });
        }
        if (labelCfg.position) {
            this.setLabelPosition(label, mappingData, index, labelCfg.position);
        }
        var offsetPoint = this.getLabelOffset(labelCfg, index, total);
        label.start = { x: label.x, y: label.y };
        label.x += offsetPoint.x;
        label.y += offsetPoint.y;
        label.color = mappingData.color;
        return label;
    };
    /**
     * 获取文本的对齐方式
     * @param item
     * @param index
     * @param total
     * @returns
     */
    GeometryLabel.prototype.getLabelAlign = function (item, index, total) {
        var align = 'center';
        var coordinate = this.coordinate;
        if (coordinate.isTransposed) {
            var offset = this.getDefaultOffset(item.offset);
            if (offset < 0) {
                align = 'right';
            }
            else if (offset === 0) {
                align = 'center';
            }
            else {
                align = 'left';
            }
            if (total > 1 && index === 0) {
                if (align === 'right') {
                    align = 'left';
                }
                else if (align === 'left') {
                    align = 'right';
                }
            }
        }
        return align;
    };
    GeometryLabel.prototype.getItems = function (mapppingArray) {
        var _this = this;
        var items = [];
        var labelCfgs = this.getLabelCfgs(mapppingArray);
        // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组
        each(mapppingArray, function (mappingData, index) {
            var labelCfg = labelCfgs[index];
            if (!labelCfg) {
                items.push(null);
                return;
            }
            var labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
            labelCfg.content = labelContent;
            var total = labelContent.length;
            each(labelContent, function (content, subIndex) {
                if (isNil(content) || content === '') {
                    items.push(null);
                    return;
                }
                var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));
                if (!item.textAlign) {
                    item.textAlign = _this.getLabelAlign(item, subIndex, total);
                }
                items.push(item);
            });
        });
        return items;
    };
    GeometryLabel.prototype.getLabelCfgs = function (mapppingArray) {
        var _this = this;
        var geometry = this.geometry;
        var defaultLabelCfg = this.defaultLabelCfg;
        var type = geometry.type, theme = geometry.theme, labelOption = geometry.labelOption, scales = geometry.scales, coordinate = geometry.coordinate;
        var _a = labelOption, fields = _a.fields, callback = _a.callback, cfg = _a.cfg;
        var labelScales = fields.map(function (field) {
            return scales[field];
        });
        var xScale = geometry.getXScale();
        var yScale = geometry.getYScale();
        var labelCfgs = [];
        each(mapppingArray, function (mappingData, index) {
            var origin = mappingData[FIELD_ORIGIN]; // 原始数据
            var originText = _this.getLabelText(origin, labelScales);
            var callbackCfg;
            if (callback) {
                // 当同时配置了 callback 和 cfg 时，以 callback 为准
                var originValues = fields.map(function (field) { return origin[field]; });
                callbackCfg = callback.apply(void 0, originValues);
                if (isNil(callbackCfg)) {
                    labelCfgs.push(null);
                    return;
                }
            }
            var labelId = geometry.getElementId(mappingData);
            if (type === 'line' || type === 'area') {
                // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值
                labelId += " " + origin[xScale.field];
            }
            else if (type === 'path') {
                // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id
                labelId += " " + origin[xScale.field] + "-" + origin[yScale.field];
            }
            var labelCfg = __assign(__assign({ id: labelId, data: origin, // 存储原始数据
                mappingData: mappingData,
                coordinate: coordinate }, cfg), callbackCfg);
            var content = labelCfg.content;
            if (isFunction(content)) {
                labelCfg.content = content(origin, mappingData, index);
            }
            else if (isUndefined(content)) {
                // 用户未配置 content，则默认为映射的第一个字段的值
                labelCfg.content = originText[0];
            }
            if (isFunction(labelCfg.position)) {
                labelCfg.position = labelCfg.position(origin, mappingData, index);
            }
            if (type === 'polygon' || (labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type))) {
                // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色
                labelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);
            }
            else {
                labelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);
            }
            labelCfgs.push(labelCfg);
        });
        return labelCfgs;
    };
    GeometryLabel.prototype.getLabelText = function (origin, scales) {
        var labelTexts = [];
        each(scales, function (scale) {
            var value = origin[scale.field];
            if (isArray(value)) {
                value = value.map(function (subVal) {
                    return scale.getText(subVal);
                });
            }
            else {
                value = scale.getText(value);
            }
            if (isNil(value) || value === '') {
                labelTexts.push(null);
            }
            else {
                labelTexts.push(value);
            }
        });
        return labelTexts;
    };
    GeometryLabel.prototype.getOffsetVector = function (offset) {
        if (offset === void 0) { offset = 0; }
        var coordinate = this.coordinate;
        // 如果 x,y 翻转，则偏移 x，否则偏移 y
        return coordinate.isTransposed ? coordinate.applyMatrix(offset, 0) : coordinate.applyMatrix(0, offset);
    };
    return GeometryLabel;
}());
export default GeometryLabel;
//# sourceMappingURL=base.js.map