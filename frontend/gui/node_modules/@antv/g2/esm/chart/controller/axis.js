import { __assign, __extends } from "tslib";
import { deepMix, each, get, map, mix } from '@antv/util';
import { COMPONENT_TYPE, DIRECTION, LAYER } from '../../constant';
import { CircleAxis, CircleGrid, LineAxis, LineGrid } from '../../dependents';
import { DEFAULT_ANIMATE_CFG } from '../../animate/';
import { getAxisDirection, getAxisFactorByRegion, getAxisRegion, getAxisThemeCfg, getAxisTitleText, getCircleAxisCenterRadius } from '../../util/axis';
import { getAxisOption } from '../../util/axis';
import { getCircleGridItems, getGridThemeCfg, getLineGridItems, showGrid } from '../../util/grid';
import { omit } from '../../util/helper';
import { Controller } from './base';
// update 组件的时候，忽略的数据更新
var OMIT_CFG = ['container'];
/**
 * @ignore
 * G2 Axis controller, will:
 *  - create component
 *    - axis
 *    - grid
 *  - life circle
 */
var Axis = /** @class */ (function (_super) {
    __extends(Axis, _super);
    function Axis(view) {
        var _this = _super.call(this, view) || this;
        /** 使用 object 存储组件 */
        _this.cache = new Map();
        // 先创建 gridContainer，将 grid 放到 axis 底层
        _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();
        _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();
        return _this;
    }
    Object.defineProperty(Axis.prototype, "name", {
        get: function () {
            return 'axis';
        },
        enumerable: true,
        configurable: true
    });
    Axis.prototype.init = function () { };
    Axis.prototype.render = function () {
        this.option = this.view.getOptions().axes;
        this.createXAxes();
        this.createYAxes();
    };
    /**
     * 更新组件布局，位置大小
     */
    Axis.prototype.layout = function () {
        var _this = this;
        var coordinate = this.view.getCoordinate();
        each(this.getComponents(), function (co) {
            var component = co.component, direction = co.direction, type = co.type, extra = co.extra;
            var dim = extra.dim, scale = extra.scale, alignTick = extra.alignTick;
            var updated;
            if (type === COMPONENT_TYPE.AXIS) {
                if (coordinate.isPolar) {
                    if (dim === 'x') {
                        updated = getCircleAxisCenterRadius(coordinate);
                    }
                    else if (dim === 'y') {
                        updated = getAxisRegion(coordinate, direction);
                    }
                }
                else {
                    updated = getAxisRegion(coordinate, direction);
                }
            }
            else if (type === COMPONENT_TYPE.GRID) {
                if (coordinate.isPolar) {
                    updated = {
                        items: dim === 'x' ?
                            // 半径 grid
                            getLineGridItems(coordinate, scale, dim, alignTick) :
                            // 圆弧 grid
                            getCircleGridItems(coordinate, _this.view.getXScale(), scale, alignTick),
                        // coordinate 更新之后，center 也变化了
                        center: _this.view.getCoordinate().getCenter(),
                    };
                }
                else {
                    updated = { items: getLineGridItems(coordinate, scale, dim, alignTick) };
                }
            }
            component.update(updated);
        });
    };
    /**
     * 更新 axis 组件
     */
    Axis.prototype.update = function () {
        this.option = this.view.getOptions().axes;
        var updatedCache = new Map();
        this.updateXAxes(updatedCache);
        this.updateYAxes(updatedCache);
        // 处理完成之后，销毁删除的
        // 不在处理中的
        var newCache = new Map();
        this.cache.forEach(function (co, key) {
            if (updatedCache.has(key)) {
                newCache.set(key, co);
            }
            else {
                // 不存在，则是所有需要被销毁的组件
                co.component.destroy();
            }
        });
        // 更新缓存
        this.cache = newCache;
    };
    Axis.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this.cache.clear();
        this.gridContainer.clear();
        this.axisContainer.clear();
    };
    Axis.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.gridContainer.remove(true);
        this.axisContainer.remove(true);
    };
    /**
     * @override
     */
    Axis.prototype.getComponents = function () {
        var co = [];
        this.cache.forEach(function (value) {
            co.push(value);
        });
        return co;
    };
    /**
     * 更新 x axis
     * @param updatedCache
     */
    Axis.prototype.updateXAxes = function (updatedCache) {
        // x axis
        var scale = this.view.getXScale();
        // @ts-ignore
        if (!scale || scale.isIdentity) {
            return;
        }
        var field = scale.field;
        var xAxisOption = getAxisOption(this.option, scale.field);
        if (xAxisOption === false) {
            return;
        }
        var coordinate = this.view.getCoordinate();
        var axisId = this.getId('axis', field);
        var gridId = this.getId('grid', field);
        var direction = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);
        var layer = LAYER.BG;
        var dim = 'x';
        if (coordinate.isRect) {
            // 1. do axis update
            var axis = this.cache.get(axisId);
            // 存在则更新
            if (axis) {
                var cfg = this.getLineAxisCfg(scale, xAxisOption, direction);
                omit(cfg, OMIT_CFG);
                axis.component.update(cfg);
                updatedCache.set(axisId, axis);
            }
            else {
                // 不存在，则创建
                axis = this.createLineAxis(scale, xAxisOption, layer, direction, dim);
                this.cache.set(axisId, axis);
                updatedCache.set(axisId, axis);
            }
            // 2. do grid update
            var grid = this.cache.get(gridId);
            // 存在则更新
            if (grid) {
                var cfg = this.getLineGridCfg(scale, xAxisOption, direction, dim);
                omit(cfg, OMIT_CFG);
                grid.component.update(cfg);
                updatedCache.set(gridId, grid);
            }
            else {
                // 不存在则创建
                grid = this.createLineGrid(scale, xAxisOption, layer, direction, dim);
                if (grid) {
                    this.cache.set(gridId, grid);
                    updatedCache.set(gridId, grid);
                }
            }
        }
        else if (coordinate.isPolar && !coordinate.isTransposed) {
            // 1. do axis update
            var axis = this.cache.get(axisId);
            // 存在则更新
            if (axis) {
                var cfg = this.getCircleAxisCfg(scale, xAxisOption, direction);
                omit(cfg, OMIT_CFG);
                axis.component.update(cfg);
                updatedCache.set(axisId, axis);
            }
            else {
                // 不存在，则创建
                axis = this.createCircleAxis(scale, xAxisOption, layer, direction, dim);
                this.cache.set(axisId, axis);
                updatedCache.set(axisId, axis);
            }
            // 2. do grid update
            var grid = this.cache.get(gridId);
            // 存在则更新
            if (grid) {
                // @ts-ignore
                var cfg = this.getLineGridCfg(scale, xAxisOption, 'circle', dim);
                omit(cfg, OMIT_CFG);
                grid.component.update(cfg);
                updatedCache.set(gridId, grid);
            }
            else {
                // 不存在则创建
                // @ts-ignore
                grid = this.createLineGrid(scale, xAxisOption, layer, 'circle', dim);
                if (grid) {
                    this.cache.set(gridId, grid);
                    updatedCache.set(gridId, grid);
                }
            }
        }
        else {
            // helix and other, do not draw axis
        }
    };
    Axis.prototype.updateYAxes = function (updatedCache) {
        var _this = this;
        // y axes
        var yScales = this.view.getYScales();
        each(yScales, function (scale, idx) {
            // @ts-ignore
            if (!scale || scale.isIdentity) {
                return;
            }
            var field = scale.field;
            var yAxisOption = getAxisOption(_this.option, field);
            if (yAxisOption !== false) {
                var layer = LAYER.BG;
                var dim = 'y';
                var axisId = _this.getId('axis', field);
                var gridId = _this.getId('grid', field);
                var coordinate = _this.view.getCoordinate();
                if (coordinate.isRect) {
                    var direction = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);
                    // 1. do axis update
                    var axis = _this.cache.get(axisId);
                    // 存在则更新
                    if (axis) {
                        var cfg = _this.getLineAxisCfg(scale, yAxisOption, direction);
                        omit(cfg, OMIT_CFG);
                        axis.component.update(cfg);
                        updatedCache.set(axisId, axis);
                    }
                    else {
                        // 不存在，则创建
                        axis = _this.createLineAxis(scale, yAxisOption, layer, direction, dim);
                        _this.cache.set(axisId, axis);
                        updatedCache.set(axisId, axis);
                    }
                    // 2. do grid update
                    var grid = _this.cache.get(gridId);
                    // 存在则更新
                    if (grid) {
                        var cfg = _this.getLineGridCfg(scale, yAxisOption, direction, dim);
                        omit(cfg, OMIT_CFG);
                        grid.component.update(cfg);
                        updatedCache.set(gridId, grid);
                    }
                    else {
                        // 不存在则创建
                        grid = _this.createLineGrid(scale, yAxisOption, layer, direction, dim);
                        if (grid) {
                            _this.cache.set(gridId, grid);
                            updatedCache.set(gridId, grid);
                        }
                    }
                }
                else if (coordinate.isPolar && !coordinate.isTransposed) {
                    // 1. do axis update
                    var axis = _this.cache.get(axisId);
                    // 存在则更新
                    if (axis) {
                        // @ts-ignore
                        var cfg = _this.getLineAxisCfg(scale, yAxisOption, 'radius');
                        omit(cfg, OMIT_CFG);
                        axis.component.update(cfg);
                        updatedCache.set(axisId, axis);
                    }
                    else {
                        // 不存在，则创建
                        // @ts-ignore
                        axis = _this.createLineAxis(scale, yAxisOption, layer, 'radius', dim);
                        _this.cache.set(axisId, axis);
                        updatedCache.set(axisId, axis);
                    }
                    // 2. do grid update
                    var grid = _this.cache.get(gridId);
                    // 存在则更新
                    if (grid) {
                        // @ts-ignore
                        var cfg = _this.getCircleGridCfg(scale, yAxisOption, 'radius', dim);
                        omit(cfg, OMIT_CFG);
                        grid.component.update(cfg);
                        updatedCache.set(gridId, grid);
                    }
                    else {
                        // 不存在则创建
                        // @ts-ignore
                        grid = _this.createCircleGrid(scale, yAxisOption, layer, 'radius');
                        if (grid) {
                            _this.cache.set(gridId, grid);
                            updatedCache.set(gridId, grid);
                        }
                    }
                }
                else {
                    // helix and other, do not draw axis
                }
            }
        });
    };
    /**
     * 创建 x axis 组件
     */
    Axis.prototype.createXAxes = function () {
        // x axis
        var scale = this.view.getXScale();
        // @ts-ignore
        if (!scale || scale.isIdentity) {
            return;
        }
        var xAxisOption = getAxisOption(this.option, scale.field);
        if (xAxisOption !== false) {
            var direction = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);
            var layer = LAYER.BG;
            var dim = 'x';
            var coordinate = this.view.getCoordinate();
            var axisId = this.getId('axis', scale.field);
            var gridId = this.getId('grid', scale.field);
            if (coordinate.isRect) {
                // axis
                var axis = this.createLineAxis(scale, xAxisOption, layer, direction, dim);
                this.cache.set(axisId, axis);
                // grid
                var grid = this.createLineGrid(scale, xAxisOption, layer, direction, dim);
                if (grid) {
                    this.cache.set(gridId, grid);
                }
            }
            else if (coordinate.isPolar && !coordinate.isTransposed) {
                // axis
                var axis = this.createCircleAxis(scale, xAxisOption, layer, direction, dim);
                this.cache.set(axisId, axis);
                // grid，极坐标下的 x 轴网格线沿着半径方向绘制
                // @ts-ignore
                var grid = this.createLineGrid(scale, xAxisOption, layer, 'circle', dim);
                if (grid) {
                    this.cache.set(gridId, grid);
                }
            }
            else {
                // helix and other, do not draw axis
            }
        }
    };
    /**
     * create y axis
     */
    Axis.prototype.createYAxes = function () {
        var _this = this;
        // y axes
        var yScales = this.view.getYScales();
        each(yScales, function (scale, idx) {
            // @ts-ignore
            if (!scale || scale.isIdentity) {
                return;
            }
            var field = scale.field;
            var yAxisOption = getAxisOption(_this.option, field);
            if (yAxisOption !== false) {
                var layer = LAYER.BG;
                var dim = 'y';
                var axisId = _this.getId('axis', field);
                var gridId = _this.getId('grid', field);
                var coordinate = _this.view.getCoordinate();
                if (coordinate.isRect) {
                    var direction = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);
                    // axis
                    var axis = _this.createLineAxis(scale, yAxisOption, layer, direction, dim);
                    _this.cache.set(axisId, axis);
                    // grid
                    var grid = _this.createLineGrid(scale, yAxisOption, layer, direction, dim);
                    if (grid) {
                        _this.cache.set(gridId, grid);
                    }
                }
                else if (coordinate.isPolar && !coordinate.isTransposed) {
                    // axis
                    // @ts-ignore
                    var axis = _this.createLineAxis(scale, yAxisOption, layer, 'radius', dim);
                    _this.cache.set(_this.getId('axis', scale.field), axis);
                    // grid
                    // @ts-ignore
                    var grid = _this.createCircleGrid(scale, yAxisOption, layer, 'radius');
                    if (grid) {
                        _this.cache.set(gridId, grid);
                    }
                }
                else {
                    // helix and other, do not draw axis
                }
            }
        });
    };
    /**
     * 创建 line axis
     * @param scale
     * @param option
     * @param layer
     * @param direction
     * @param dim
     */
    Axis.prototype.createLineAxis = function (scale, option, layer, direction, dim) {
        // axis
        var axis = {
            component: new LineAxis(this.getLineAxisCfg(scale, option, direction)),
            layer: layer,
            // @ts-ignore
            direction: direction === 'radius' ? DIRECTION.NONE : direction,
            type: COMPONENT_TYPE.AXIS,
            extra: { dim: dim, scale: scale },
        };
        axis.component.set('field', scale.field);
        axis.component.init();
        return axis;
    };
    Axis.prototype.createLineGrid = function (scale, option, layer, direction, dim) {
        var cfg = this.getLineGridCfg(scale, option, direction, dim);
        if (cfg) {
            var grid = {
                component: new LineGrid(cfg),
                layer: layer,
                direction: DIRECTION.NONE,
                type: COMPONENT_TYPE.GRID,
                extra: {
                    dim: dim,
                    scale: scale,
                    alignTick: get(cfg, 'alignTick', true),
                },
            };
            grid.component.init();
            return grid;
        }
    };
    Axis.prototype.createCircleAxis = function (scale, option, layer, direction, dim) {
        var axis = {
            component: new CircleAxis(this.getCircleAxisCfg(scale, option, direction)),
            layer: layer,
            direction: direction,
            type: COMPONENT_TYPE.AXIS,
            extra: { dim: dim, scale: scale },
        };
        axis.component.set('field', scale.field);
        axis.component.init();
        return axis;
    };
    Axis.prototype.createCircleGrid = function (scale, option, layer, direction) {
        var cfg = this.getCircleGridCfg(scale, option, direction);
        if (cfg) {
            var grid = {
                component: new CircleGrid(cfg),
                layer: layer,
                direction: DIRECTION.NONE,
                type: COMPONENT_TYPE.GRID,
                extra: {
                    dim: 'y',
                    scale: scale,
                    alignTick: get(cfg, 'alignTick', true),
                },
            };
            grid.component.init();
            return grid;
        }
    };
    /**
     * generate line axis cfg
     * @param scale
     * @param axisOption
     * @param direction
     * @return line axis cfg
     */
    Axis.prototype.getLineAxisCfg = function (scale, axisOption, direction) {
        var container = this.axisContainer;
        var coordinate = this.view.getCoordinate();
        var region = getAxisRegion(coordinate, direction);
        var titleText = getAxisTitleText(scale, axisOption);
        var baseAxisCfg = __assign(__assign({ container: container }, region), { ticks: map(scale.getTicks(), function (tick) { return ({ id: "" + tick.tickValue, name: tick.text, value: tick.value }); }), title: {
                text: titleText,
            }, verticalFactor: coordinate.isPolar
                ? getAxisFactorByRegion(region, coordinate.getCenter()) * -1
                : getAxisFactorByRegion(region, coordinate.getCenter()) });
        var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction);
        // the cfg order should be ensure
        var optionWithTitle = get(axisOption, ['title'])
            ? deepMix({}, { title: { style: { text: titleText } } }, axisOption)
            : axisOption;
        var cfg = deepMix({}, baseAxisCfg, axisThemeCfg, optionWithTitle);
        return mix(cfg, this.getAnimateCfg(cfg));
    };
    /**
     * generate line grid cfg
     * @param scale
     * @param axisOption
     * @param direction
     * @param dim
     * @return line grid cfg
     */
    Axis.prototype.getLineGridCfg = function (scale, axisOption, direction, dim) {
        if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {
            return undefined;
        }
        var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction);
        // the cfg order should be ensure
        // grid 动画以 axis 为准
        var gridCfg = deepMix({
            container: this.gridContainer,
        }, gridThemeCfg, get(axisOption, 'grid', {}), this.getAnimateCfg(axisOption));
        gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale, dim, get(gridCfg, 'alignTick', true));
        return gridCfg;
    };
    /**
     * generate circle axis cfg
     * @param scale
     * @param axisOption
     * @param direction
     * @return circle axis cfg
     */
    Axis.prototype.getCircleAxisCfg = function (scale, axisOption, direction) {
        var container = this.axisContainer;
        var ticks = map(scale.getTicks(), function (tick) { return ({ id: "" + tick.tickValue, name: tick.text, value: tick.value }); });
        var coordinate = this.view.getCoordinate();
        if (!scale.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {
            // x 轴对应的值如果是非 cat 类型，在整圆的情况下坐标轴第一个和最后一个文本会重叠，默认只展示第一个文本
            ticks.pop();
        }
        var titleText = getAxisTitleText(scale, axisOption);
        var baseAxisCfg = __assign(__assign({ container: container }, getCircleAxisCenterRadius(this.view.getCoordinate())), { ticks: ticks, title: {
                text: titleText,
            }, verticalFactor: 1 });
        var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), 'circle');
        // the cfg order should be ensure
        var optionWithTitle = get(axisOption, ['title'])
            ? deepMix({}, { title: { style: { text: titleText } } }, axisOption)
            : axisOption;
        var cfg = deepMix({}, baseAxisCfg, axisThemeCfg, optionWithTitle);
        return mix(cfg, this.getAnimateCfg(cfg));
    };
    /**
     * generate circle grid cfg
     * @param scale
     * @param axisOption
     * @param direction
     * @return circle grid cfg
     */
    Axis.prototype.getCircleGridCfg = function (scale, axisOption, direction) {
        if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {
            return undefined;
        }
        // the cfg order should be ensure
        // grid 动画以 axis 为准
        // @ts-ignore
        var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), 'radius');
        var gridCfg = deepMix({
            container: this.gridContainer,
            center: this.view.getCoordinate().getCenter(),
        }, gridThemeCfg, get(axisOption, 'grid', {}), this.getAnimateCfg(axisOption));
        var alignTick = get(gridCfg, 'alignTick', true);
        gridCfg.items = getCircleGridItems(this.view.getCoordinate(), this.view.getXScale(), scale, alignTick);
        // the cfg order should be ensure
        // grid 动画以 axis 为准
        return gridCfg;
    };
    Axis.prototype.getId = function (name, key) {
        var coordinate = this.view.getCoordinate();
        // 坐标系类型也作为组件的 key
        return name + "-" + key + "-" + coordinate.type;
    };
    Axis.prototype.getAnimateCfg = function (cfg) {
        return {
            animate: this.view.getOptions().animate && get(cfg, 'animate'),
            animateOption: deepMix({}, DEFAULT_ANIMATE_CFG, {
                appear: null,
            }, get(cfg, 'animateOption', {})),
        };
    };
    return Axis;
}(Controller));
export default Axis;
//# sourceMappingURL=axis.js.map