import { __extends } from "tslib";
import * as _ from '@antv/util';
import { DODGE_RATIO, MARGIN_RATIO } from '../constant';
import Adjust from './adjust';
var Dodge = /** @class */ (function (_super) {
    __extends(Dodge, _super);
    function Dodge(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.cacheMap = {};
        _this.adjustDataArray = [];
        _this.mergeData = [];
        var _a = cfg.marginRatio, marginRatio = _a === void 0 ? MARGIN_RATIO : _a, _b = cfg.dodgeRatio, dodgeRatio = _b === void 0 ? DODGE_RATIO : _b, dodgeBy = cfg.dodgeBy;
        _this.marginRatio = marginRatio;
        _this.dodgeRatio = dodgeRatio;
        _this.dodgeBy = dodgeBy;
        return _this;
    }
    Dodge.prototype.process = function (groupDataArray) {
        var groupedDataArray = _.clone(groupDataArray);
        // 将数据数组展开一层
        var mergeData = _.flatten(groupedDataArray);
        var dodgeBy = this.dodgeBy;
        // 如果指定了分组 dim 的字段
        var adjustDataArray = dodgeBy ? _.group(mergeData, dodgeBy) : groupedDataArray;
        this.cacheMap = {};
        this.adjustDataArray = adjustDataArray;
        this.mergeData = mergeData;
        this.adjustData(adjustDataArray, mergeData);
        this.adjustDataArray = [];
        this.mergeData = [];
        return groupedDataArray;
    };
    Dodge.prototype.adjustDim = function (dim, values, data, frameIndex) {
        var _this = this;
        var map = this.getDistribution(dim);
        var groupData = this.groupData(data, dim); // 根据值分组
        _.each(groupData, function (group, key) {
            var range;
            // xField 中只有一个值，不需要做 dodge
            if (values.length === 1) {
                range = {
                    pre: values[0] - 1,
                    next: values[0] + 1,
                };
            }
            else {
                // 如果有多个，则需要获取调整的范围
                range = _this.getAdjustRange(dim, parseFloat(key), values);
            }
            _.each(group, function (d) {
                var value = d[dim];
                var valueArr = map[value];
                var valIndex = valueArr.indexOf(frameIndex);
                d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);
            });
        });
        return [];
    };
    Dodge.prototype.getDodgeOffset = function (range, idx, len) {
        var _a = this, dodgeRatio = _a.dodgeRatio, marginRatio = _a.marginRatio;
        var pre = range.pre, next = range.next;
        var tickLength = next - pre;
        var width = (tickLength * dodgeRatio) / len;
        var margin = marginRatio * width;
        var offset = (1 / 2) * (tickLength - len * width - (len - 1) * margin) +
            ((idx + 1) * width + idx * margin) -
            (1 / 2) * width -
            (1 / 2) * tickLength;
        return (pre + next) / 2 + offset;
    };
    Dodge.prototype.getDistribution = function (dim) {
        var groupedDataArray = this.adjustDataArray;
        var cacheMap = this.cacheMap;
        var map = cacheMap[dim];
        if (!map) {
            map = {};
            _.each(groupedDataArray, function (data, index) {
                var values = _.valuesOfKey(data, dim);
                if (!values.length) {
                    values.push(0);
                }
                _.each(values, function (val) {
                    if (!map[val]) {
                        map[val] = [];
                    }
                    map[val].push(index);
                });
            });
            cacheMap[dim] = map;
        }
        return map;
    };
    return Dodge;
}(Adjust));
export default Dodge;
//# sourceMappingURL=dodge.js.map