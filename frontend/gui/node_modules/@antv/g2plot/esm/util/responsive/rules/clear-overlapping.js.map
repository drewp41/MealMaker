{"version":3,"file":"clear-overlapping.js","sourceRoot":"","sources":["../../../../src/util/responsive/rules/clear-overlapping.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,IAAI,EAAE,MAAM,YAAY,CAAC;AAClC,OAAO,QAAQ,MAAM,aAAa,CAAC;AAEnC,MAAM,CAAC,OAAO,UAAU,gBAAgB,CAAC,KAAa,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;IACxE,IAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC;IAC9B,IAAM,OAAO,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;IAC7B,IAAM,UAAU,GAAG,EAAE,CAAC;IACtB,2BAA2B;IAC3B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;QAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,IAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;YAC1B,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;gBACvC,IAAM,SAAS,GAAG,aAAa,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;gBAC/C,IAAI,SAAS,EAAE;oBACb,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBACvB;aACF;SACF;KACF;IACD,kBAAkB;IAClB,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;QACzB,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACzB,UAAU,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;YACnB,OAAO,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC;QACvB,CAAC,CAAC,CAAC;QACH,oBAAoB;QACpB,IAAI,CAAC,UAAU,EAAE,UAAC,IAAS,EAAE,GAAW;YACtC,IAAI,GAAG,GAAG,CAAC,EAAE;gBACX,IAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;gBAC1B,QAAQ,CAAC,MAAM,CAAC,CAAC;gBACjB,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;aAC3B;QACH,CAAC,CAAC,CAAC;KACJ;AACH,CAAC;AAED,MAAM,UAAU,aAAa,CAAC,KAAK,EAAE,KAAK;IACxC,IAAI,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,GAAG,IAAI,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE;QACxD,OAAO,KAAK,CAAC;KACd;IACD,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,EAAE;QACxD,OAAO,KAAK,CAAC;KACd;IACD,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["import { IShape } from '@antv/g-base';\nimport { each } from '@antv/util';\nimport textHide from './text-hide';\n\nexport default function clearOverlapping(shape: IShape, option, index, cfg) {\n  const nodes = cfg.nodes.nodes;\n  const current = nodes[index];\n  const overlapped = [];\n  /** 找到所有与当前点overlap的node */\n  if (!current.shape.get('blank')) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const _shape = node.shape;\n      if (i !== index && !_shape.get('blank')) {\n        const isOverlap = isNodeOverlap(current, node);\n        if (isOverlap) {\n          overlapped.push(node);\n        }\n      }\n    }\n  }\n  /** overlap处理逻辑 */\n  if (overlapped.length > 0) {\n    overlapped.push(current);\n    overlapped.sort((a, b) => {\n      return b.top - a.top;\n    });\n    /** 隐藏除最高点以外的node */\n    each(overlapped, (node: any, idx: number) => {\n      if (idx > 0) {\n        const _shape = node.shape;\n        textHide(_shape);\n        _shape.set('blank', true);\n      }\n    });\n  }\n}\n\nexport function isNodeOverlap(nodeA, nodeB) {\n  if (nodeA.bottom < nodeB.top || nodeB.bottom < nodeA.top) {\n    return false;\n  }\n  if (nodeA.right < nodeB.left || nodeB.right < nodeA.left) {\n    return false;\n  }\n  return true;\n}\n"]}