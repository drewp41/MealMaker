import { __assign, __extends } from "tslib";
import { deepMix, has, map, each } from '@antv/util';
import { registerPlotType } from '../../base/global';
import ViewLayer from '../../base/view-layer';
import { getComponent } from '../../components/factory';
import { getGeom } from '../../geoms/factory';
import { extractScale, trySetScaleMinToZero } from '../../util/scale';
import { getPlotOption } from './animation/clipIn-with-data';
import responsiveMethods from './apply-responsive';
import LineLabel from './component/label/line-label';
import * as EventParser from './event';
import './theme';
import './apply-responsive/theme';
import { LineActive, LineSelect } from './interaction/index';
var GEOM_MAP = {
    line: 'line',
    point: 'point',
};
var LineLayer = /** @class */ (function (_super) {
    __extends(LineLayer, _super);
    function LineLayer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'line';
        return _this;
    }
    LineLayer.getDefaultOptions = function () {
        return deepMix({}, _super.getDefaultOptions.call(this), {
            connectNulls: false,
            smooth: false,
            lineSize: 2,
            lineStyle: {
                lineJoin: 'round',
                lineCap: 'round',
            },
            point: {
                visible: false,
                size: 3,
                shape: 'circle',
                style: {
                    stroke: '#fff',
                },
            },
            label: {
                visible: false,
                type: 'point',
            },
            legend: {
                visible: true,
                position: 'top-left',
                wordSpacing: 4,
            },
        });
    };
    LineLayer.prototype.afterRender = function () {
        var props = this.options;
        if (this.options.label && this.options.label.visible && this.options.label.type === 'line') {
            var label = new LineLabel(__assign({ view: this.view, plot: this }, this.options.label));
            label.render();
        }
        // 响应式
        if (props.responsive && props.padding !== 'auto') {
            this.applyResponsive('afterRender');
        }
        _super.prototype.afterRender.call(this);
    };
    LineLayer.prototype.geometryParser = function (dim, type) {
        return GEOM_MAP[type];
    };
    LineLayer.prototype.scale = function () {
        var props = this.options;
        var scales = {};
        /** 配置x-scale */
        scales[props.xField] = {};
        if (has(props, 'xAxis')) {
            extractScale(scales[props.xField], props.xAxis);
        }
        /** 配置y-scale */
        scales[props.yField] = {};
        if (has(props, 'yAxis')) {
            extractScale(scales[props.yField], props.yAxis);
        }
        this.setConfig('scales', scales);
        trySetScaleMinToZero(scales[props.yField], map(props.data, function (item) { return item[props.yField]; }));
        _super.prototype.scale.call(this);
    };
    LineLayer.prototype.coord = function () { };
    LineLayer.prototype.addGeometry = function () {
        // 配置线
        this.addLine();
        // 配置数据点
        this.addPoint();
    };
    LineLayer.prototype.addLine = function () {
        var props = this.options;
        this.line = getGeom('line', 'main', {
            plot: this,
        });
        if (props.label) {
            this.label();
        }
        if (props.tooltip && (props.tooltip.fields || props.tooltip.formatter)) {
            this.geometryTooltip();
        }
        this.setConfig('geometry', this.line);
    };
    LineLayer.prototype.addPoint = function () {
        var props = this.options;
        var defaultConfig = { visible: false };
        if (props.point) {
            props.point = deepMix(defaultConfig, props.point);
        }
        if (props.point && props.point.visible) {
            this.point = getGeom('point', 'guide', {
                plot: this,
            });
            this.setConfig('geometry', this.point);
        }
    };
    LineLayer.prototype.label = function () {
        var props = this.options;
        var label = props.label;
        if (label.visible === false || this.singleLineLabelCheck()) {
            this.line.label = false;
            return;
        }
        /** label类型为point时，使用g2默认label */
        if (label.type === 'point') {
            this.line.label = getComponent('label', __assign({ plot: this, top: true, labelType: label.type, fields: [props.yField] }, label));
        }
    };
    LineLayer.prototype.geometryTooltip = function () {
        this.line.tooltip = {};
        var tooltipOptions = this.options.tooltip;
        if (tooltipOptions.fields) {
            this.line.tooltip.fields = tooltipOptions.fields;
        }
        if (tooltipOptions.formatter) {
            this.line.tooltip.callback = tooltipOptions.formatter;
            if (!tooltipOptions.fields) {
                this.line.tooltip.fields = [this.options.xField, this.options.yField];
                if (this.options.seriesField) {
                    this.line.tooltip.fields.push(this.options.seriesField);
                }
            }
        }
    };
    LineLayer.prototype.animation = function () {
        _super.prototype.animation.call(this);
        var props = this.options;
        if (props.animation === false) {
            // 关闭动画
            this.line.animate = false;
            if (this.point)
                this.point.animate = false;
        }
        else if (has(props, 'animation')) {
            // 根据动画类型区分图形动画和群组动画
            if (props.animation.type === 'clipingWithData' && props.padding !== 'auto') {
                getPlotOption({
                    options: this.options,
                    view: this.view,
                });
                this.line.animate = {
                    appear: {
                        animation: 'clipingWithData',
                        easing: 'easeLinear',
                        duration: 10000,
                        options: {
                            test: true,
                        },
                        yField: props.yField,
                        seriesField: props.seriesField,
                        plot: this,
                    },
                };
                // 如果有数据点的话要追加数据点的动画
                if (props.point && props.point.visible) {
                    this.point.animate = false;
                }
            }
        }
    };
    LineLayer.prototype.applyInteractions = function () {
        _super.prototype.applyInteractions.call(this);
        this.interactions.push(new LineActive({
            view: this.view,
        }));
        this.interactions.push(new LineSelect({
            view: this.view,
        }));
    };
    LineLayer.prototype.parseEvents = function (eventParser) {
        _super.prototype.parseEvents.call(this, EventParser);
    };
    LineLayer.prototype.applyResponsive = function (stage) {
        var _this = this;
        var methods = responsiveMethods[stage];
        each(methods, function (r) {
            var responsive = r;
            responsive.method(_this);
        });
    };
    LineLayer.prototype.singleLineLabelCheck = function () {
        // 不允许单折线设置尾部跟随label
        return !this.options.seriesField && this.options.label.type && this.options.label.type === 'line';
    };
    return LineLayer;
}(ViewLayer));
export default LineLayer;
registerPlotType('line', LineLayer);
//# sourceMappingURL=layer.js.map