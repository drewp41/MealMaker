import { __assign } from "tslib";
/**
 * @author linhuiw
 * @description 仪表盘形状
 */
import { get } from '@antv/util';
import { registerShape } from '@antv/g2';
import { getGlobalTheme } from '../../../../theme';
import { sortedLastIndex } from '../../../../util/common';
/**
 * 仪表盘指针图形
 * 指针主体由梯形和一大一小圆形组成，
 * 中心处由灰色圆底和小白圆加以装饰
 */
var GaugeShape = /** @class */ (function () {
    function GaugeShape(uid) {
        this.uid = uid;
    }
    GaugeShape.prototype.setOption = function (type, options, pointerStyle, ringStyle) {
        this.type = type;
        this.options = options;
        this.pointerStyle = pointerStyle;
        this.ringStyle = ringStyle;
    };
    GaugeShape.prototype.render = function () {
        var Gauge = this; // eslint-disable-line
        registerShape('point', 'gauge', {
            draw: function (cfg, group) {
                this.gauge = {};
                this.gauge.options = Gauge.options;
                this.gauge.pointerStyle = Gauge.pointerStyle;
                this.gauge.ringStyle = Gauge.ringStyle;
                this.gauge.type = Gauge.type;
                var gauge = this.gauge;
                var type = this.gauge.type;
                var point = cfg.points[0];
                var center = this.parsePoint({
                    x: 0,
                    y: 0,
                });
                var target = this.parsePoint({
                    x: point.x || 0,
                    y: 1,
                });
                gauge.center = center;
                gauge.group = group;
                var r = { x: center.x - target.x, y: center.y - target.y };
                this.gauge.ringRadius = Math.sqrt(r.x * r.x + r.y * r.y) - 10;
                var _a = this.getAngleRange(), starAngle = _a.starAngle, endAngle = _a.endAngle;
                var currentAngle = point.x * (endAngle - starAngle) + starAngle;
                switch (type) {
                    case 'meterGauge':
                        this.drawBarGauge(currentAngle);
                        this.drawInSideAxis();
                        break;
                    case 'fanGauge':
                        this.drawGauge(currentAngle);
                        this.drawOutSideAxis();
                        break;
                    case 'standardGauge':
                    default:
                        this.drawGauge(currentAngle);
                        this.drawAxis();
                        break;
                }
                // 绘制指针
                this.drawPoniter(cfg, group);
            },
            drawGauge: function (currentAngle) {
                var range = this.gauge.options.range;
                this.drawBottomRing(); // 绘制灰底色
                if (range && range.length) {
                    this.drawRangeColor();
                }
                else {
                    this.drawCurrentRing(currentAngle);
                }
            },
            drawRangeColor: function () {
                var _a = this.gauge.options, min = _a.min, max = _a.max, range = _a.range, styleMix = _a.styleMix, color = _a.color;
                var colors = color || getGlobalTheme().colors;
                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;
                var config = {
                    min: min,
                    max: max,
                    starAngle: starAngle,
                    endAngle: endAngle,
                };
                for (var i = 0; i < range.length; i++) {
                    var start = this.valueToAngle(range[i], config);
                    var end = this.valueToAngle(range[i + 1], config);
                    if (end >= start) {
                        var path2 = this.getPath(start, end);
                        this.drawRing(path2, colors[i]);
                    }
                }
            },
            drawBottomRing: function () {
                var _a = this.getAngleRange(), starAngle = _a.starAngle, endAngle = _a.endAngle;
                var background = this.gauge.ringStyle.background;
                var path = this.getPath(starAngle, endAngle);
                this.drawRing(path, background);
            },
            drawCurrentRing: function (current) {
                var starAngle = this.getAngleRange().starAngle;
                var color = this.gauge.ringStyle.color;
                var path3 = this.getPath(starAngle, current);
                this.drawRing(path3, color);
            },
            drawInSideAxis: function () {
                var axis = this.gauge.ringStyle.axis;
                var amount = axis.amount;
                var _a = this.gauge.options, min = _a.min, max = _a.max;
                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;
                var config = {
                    min: min,
                    max: max,
                    starAngle: starAngle,
                    endAngle: endAngle,
                };
                var interval = (max - min) / amount;
                for (var i = 0; i < amount; i++) {
                    var startValue = min + i * interval;
                    var angle = this.valueToAngle(startValue + interval / 2, config);
                    this.drawRect(angle);
                }
            },
            drawAxis: function () {
                var axis = this.gauge.ringStyle.axis;
                var amount = axis.amount, length = axis.length, thickness = axis.thickness;
                var _a = this.gauge.options, min = _a.min, max = _a.max;
                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;
                var config = {
                    min: min,
                    max: max,
                    starAngle: starAngle,
                    endAngle: endAngle,
                };
                var interval = (max - min) / (amount - 1);
                for (var i = 0; i < amount; i++) {
                    var startValue = min + i * interval;
                    var angle = this.valueToAngle(startValue, config);
                    this.drawRect(angle, {
                        length: i % 5 === 0 ? length : length / 2,
                        thickness: i % 5 === 0 ? thickness : thickness / 2,
                    });
                }
            },
            drawOutSideAxis: function () {
                var axis = this.gauge.ringStyle.axis;
                var amount = axis.amount;
                var _a = this.gauge.options, min = _a.min, max = _a.max;
                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;
                var config = {
                    min: min,
                    max: max,
                    starAngle: starAngle,
                    endAngle: endAngle,
                };
                var interval = (max - min) / (amount - 1);
                for (var i = 0; i < amount; i++) {
                    var startValue = min + i * interval;
                    var angle = this.valueToAngle(startValue, config);
                    this.drawRect(angle);
                }
            },
            drawBarGauge: function (current) {
                var _this = this;
                var _a = this.gauge.options, min = _a.min, max = _a.max, range = _a.range, styleMix = _a.styleMix;
                var colors = styleMix.colors || getGlobalTheme().colors;
                var _b = this.gauge.ringStyle, color = _b.color, background = _b.background;
                var _c = this.getAngleRange(), starAngle = _c.starAngle, endAngle = _c.endAngle;
                var config = {
                    min: min,
                    max: max,
                    starAngle: starAngle,
                    endAngle: endAngle,
                };
                var interval = (endAngle - starAngle) / (50 - 1);
                var offset = interval / 3;
                // 由50个柱子组成
                for (var i = 0; i < 50; i++) {
                    var start = starAngle + i * interval;
                    var path2 = this.getPath(start - offset / 2, start + offset - offset / 2);
                    var fillColor = background;
                    if (range && range.length) {
                        var result1 = range.map(function (item) {
                            return _this.valueToAngle(item, config);
                        });
                        var index = sortedLastIndex(result1, start);
                        /** 最后一个值也在最后一个区间内 */
                        var colorIndex = Math.min(index, range.length - 1);
                        fillColor = colors[colorIndex - 1] || background;
                    }
                    else {
                        fillColor = current >= start ? color : background;
                    }
                    this.drawRing(path2, fillColor);
                }
            },
            getAngleRange: function () {
                var angle = this.gauge.ringStyle.angle;
                var angleValue = 90 - (360 - angle) * 0.5;
                var starAngle = ((270 - 90 - angleValue) * Math.PI) / 180;
                var endAngle = ((270 + 90 + angleValue) * Math.PI) / 180;
                return { starAngle: starAngle, endAngle: endAngle };
            },
            valueToAngle: function (value, config) {
                var min = config.min, max = config.max, starAngle = config.starAngle, endAngle = config.endAngle;
                if (value === max) {
                    return endAngle;
                }
                if (value === min) {
                    return starAngle;
                }
                var ratio = (value - min) / (max - min);
                if (max === min) {
                    ratio = 1;
                }
                var angle = ratio * (endAngle - starAngle) + starAngle;
                angle = Math.max(angle, starAngle);
                angle = Math.min(angle, endAngle);
                return angle;
            },
            drawRing: function (path, color) {
                this.gauge.group.addShape('path', {
                    attrs: {
                        path: path,
                        fill: color,
                    },
                });
            },
            drawRect: function (angle, param) {
                var axis = this.gauge.ringStyle.axis;
                var config = __assign(__assign({}, axis), param);
                var offset = config.offset, length = config.length, thickness = config.thickness, color = config.color;
                var center = this.gauge.center;
                var radius = this.gauge.ringRadius + offset;
                var xA1 = radius * Math.cos(angle) + center.x;
                var yA1 = radius * Math.sin(angle) + center.y;
                var xB1 = (radius + length) * Math.cos(angle) + center.x;
                var yB1 = (radius + length) * Math.sin(angle) + center.y;
                this.gauge.group.addShape('line', {
                    attrs: {
                        x1: xA1,
                        y1: yA1,
                        x2: xB1,
                        y2: yB1,
                        stroke: color,
                        lineWidth: thickness,
                    },
                });
            },
            getPath: function (starAngle, endAngle) {
                var gauge = this.gauge;
                var type = this.gauge.type;
                var height = get(gauge, 'options.height');
                var width = get(gauge, 'options.width');
                var center = this.gauge.center;
                var length = this.gauge.ringRadius;
                var _a = this.gauge.ringStyle, thickness = _a.thickness, minThickness = _a.minThickness, minThickCanvsSize = _a.minThickCanvsSize, miniThickness = _a.miniThickness, bigThickness = _a.bigThickness;
                var thick;
                var size = Math.min(width, height);
                if (type === 'fan' && size < minThickCanvsSize) {
                    thick = length - minThickness;
                }
                else {
                    thick = thickness;
                }
                var xA1 = length * Math.cos(starAngle) + center.x;
                var yA1 = length * Math.sin(starAngle) + center.y;
                var xA2 = (length - thick) * Math.cos(starAngle) + center.x;
                var yA2 = (length - thick) * Math.sin(starAngle) + center.y;
                var xB1 = length * Math.cos(endAngle) + center.x;
                var yB1 = length * Math.sin(endAngle) + center.y;
                var xB2 = (length - thick) * Math.cos(endAngle) + center.x;
                var yB2 = (length - thick) * Math.sin(endAngle) + center.y;
                var largeArcFlag = Math.abs(starAngle - endAngle) > Math.PI ? 1 : 0;
                return [
                    ['M', xA1, yA1],
                    ['A', length, length, 0, largeArcFlag, 1, xB1, yB1],
                    ['L', xB2, yB2],
                    ['A', length - thick, length - thick, 0, largeArcFlag, 0, xA2, yA2],
                    ['Z'],
                ];
            },
            drawPoniter: function (cfg) {
                var _a = this.getAngleRange(), starAngle = _a.starAngle, endAngle = _a.endAngle;
                var _b = this.gauge.pointerStyle, color = _b.color, circleColorTop = _b.circleColorTop, circleColorBottom = _b.circleColorBottom, radius = _b.radius, thickness = _b.thickness;
                var bigCircle = thickness;
                var smCircle = thickness / 2.5;
                var group = this.gauge.group;
                var point = cfg.points[0];
                var center = this.parsePoint({
                    x: 0,
                    y: 0,
                });
                // *radius
                var current = point.x * (endAngle - starAngle) + starAngle;
                var x = this.gauge.ringRadius * radius * Math.cos(current) + this.gauge.center.x;
                var y = this.gauge.ringRadius * radius * Math.sin(current) + this.gauge.center.y;
                var target = {
                    x: x,
                    y: y,
                };
                // 外底色灰圆
                group.addShape('circle', {
                    attrs: {
                        x: center.x,
                        y: center.y,
                        r: bigCircle * 2.2,
                        fill: circleColorBottom,
                    },
                });
                var dirVec = { x: center.x - target.x, y: center.y - target.y };
                var length = Math.sqrt(dirVec.x * dirVec.x + dirVec.y * dirVec.y);
                dirVec.x *= 1 / length;
                dirVec.y *= 1 / length;
                var angle1 = -Math.PI / 2;
                var x1 = Math.cos(angle1) * dirVec.x - Math.sin(angle1) * dirVec.y;
                var y1 = Math.sin(angle1) * dirVec.x + Math.cos(angle1) * dirVec.y;
                var angle2 = Math.PI / 2;
                var x2 = Math.cos(angle2) * dirVec.x - Math.sin(angle2) * dirVec.y;
                var y2 = Math.sin(angle2) * dirVec.x + Math.cos(angle2) * dirVec.y;
                var path = [
                    ['M', target.x + x1 * smCircle, target.y + y1 * smCircle],
                    ['L', center.x + x1 * bigCircle, center.y + y1 * bigCircle],
                    ['L', center.x + x2 * bigCircle, center.y + y2 * bigCircle],
                    ['L', target.x + x2 * smCircle, target.y + y2 * smCircle],
                    ['Z'],
                ];
                group.addShape('path', {
                    attrs: {
                        path: path,
                        fill: color,
                        stroke: color,
                    },
                });
                group.addShape('circle', {
                    attrs: {
                        x: target.x,
                        y: target.y,
                        r: smCircle,
                        fill: color,
                    },
                });
                group.addShape('circle', {
                    attrs: {
                        x: center.x,
                        y: center.y,
                        r: bigCircle,
                        fill: color,
                    },
                });
                // 内部白色小圆
                group.addShape('circle', {
                    attrs: {
                        x: center.x,
                        y: center.y,
                        r: smCircle / 1.2,
                        fill: circleColorTop,
                    },
                });
            },
        });
    };
    return GaugeShape;
}());
export { GaugeShape };
//# sourceMappingURL=gauge-shape.js.map