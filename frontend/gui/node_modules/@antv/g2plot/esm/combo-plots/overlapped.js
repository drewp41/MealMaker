import { __extends } from "tslib";
import ComboPlot from './base';
import * as _ from '@antv/util';
import { getPlotType } from '../base/global';
import Layer from '../base/layer';
import '../plots/index';
import * as ComboUtil from './util';
import { getOverlappingPadding } from './util/padding';
import { getGlobalTheme } from '../theme/global';
var OverlappedComboPlot = /** @class */ (function (_super) {
    __extends(OverlappedComboPlot, _super);
    function OverlappedComboPlot(container, props) {
        var _this = _super.call(this, container, props) || this;
        _this.options = props;
        return _this;
    }
    OverlappedComboPlot.prototype.getDefaultOptions = function () {
        return {
            xAxis: {
                visible: true,
                autoHideLabel: false,
                autoRotateLabel: false,
                autoRotateTitle: false,
                grid: {
                    visible: false,
                },
                line: {
                    visible: true,
                },
                tickLine: {
                    visible: true,
                },
                label: {
                    visible: true,
                },
                title: {
                    visible: false,
                    offset: 12,
                },
            },
            yAxis: {
                visible: true,
                autoHideLabel: false,
                autoRotateLabel: false,
                autoRotateTitle: true,
                grid: {
                    visible: true,
                },
                line: {
                    visible: true,
                },
                tickLine: {
                    visible: true,
                },
                label: {
                    visible: true,
                },
                title: {
                    visible: false,
                    offset: 12,
                },
                colorMapping: true,
                synchroTick: true,
            },
            label: {
                visible: false,
            },
            tooltip: {
                visible: true,
                sort: true,
            },
            legend: {
                visible: true,
                position: 'top-left',
            },
            animation: false,
        };
    };
    OverlappedComboPlot.prototype.createComboLayers = function () {
        var _this = this;
        this.options.layers = this.layerOptionsFilter(this.options.layers);
        _super.prototype.createComboLayers.call(this);
        this.legendInfo = [];
        this.axisInfo = [];
        this.paddingComponents = [];
        this.globalComponents = [];
        this.singleGeomCount = 0;
        this.backLayer = new Layer({
            canvas: this.getCanvas(),
            width: this.width,
            height: this.height,
        });
        if (this.options.layers.length > 0) {
            /** create layers */
            _.each(this.options.layers, function (layerCfg) {
                var _a, _b;
                var overlapConfig = _this.getOverlappedConfig(layerCfg);
                var viewLayerCtr = getPlotType(layerCfg.type);
                var viewLayerProps = _.deepMix({}, layerCfg, {
                    canvas: _this.canvas,
                    x: 0,
                    y: 0,
                    width: _this.width,
                    height: _this.height,
                    tooltip: {
                        domStyles: {
                            'g2-tooltip': {
                                display: 'none',
                            },
                        },
                    },
                }, overlapConfig);
                var viewLayer = new viewLayerCtr(viewLayerProps);
                viewLayer.render();
                viewLayer.hide();
                (_a = _this.axisInfo).push.apply(_a, ComboUtil.getAxisData(viewLayer, viewLayerProps, _this.globalOptions));
                (_b = _this.legendInfo).push.apply(_b, ComboUtil.getLegendData(viewLayer, viewLayerProps));
                _this.addLayer(viewLayer);
            });
        }
        /** add top layer for legend & tooltip */
        this.topLayer = new Layer({
            canvas: this.getCanvas(),
            width: this.width,
            height: this.height,
        });
        this.topLayer.render();
    };
    /** 图层叠加时的layer config */
    OverlappedComboPlot.prototype.getOverlappedConfig = function (layerCfg) {
        var colorCfg = ComboUtil.getColorConfig(layerCfg.type, layerCfg, this.singleGeomCount);
        if (colorCfg && colorCfg.single) {
            this.singleGeomCount++;
        }
        return _.deepMix({}, {
            xAxis: {
                visible: false,
            },
            yAxis: {
                visible: false,
            },
            legend: {
                visible: false,
            },
            /* tooltip: {
              visible: false,
            },*/
            padding: [0, 0, 0, 0],
            color: colorCfg ? colorCfg.color : null,
        });
    };
    OverlappedComboPlot.prototype.overlappingLegend = function () {
        var legendItems = ComboUtil.mergeLegendData(this.legendInfo);
        this.legendContainer = this.topLayer.container.addGroup();
        return ComboUtil.createLegend(legendItems, this.width, this.height, this.getCanvas(), this.globalOptions.legend.position);
    };
    OverlappedComboPlot.prototype.render = function () {
        var _a;
        var _this = this;
        this.doDestroy();
        this.createComboLayers();
        if (this.layers.length < 1) {
            return;
        }
        var bleeding = getGlobalTheme().bleeding;
        if (this.globalOptions.legend.visible) {
            var legend = this.overlappingLegend();
            this.globalComponents.push({ type: 'legend', component: legend.component });
            this.paddingComponents.push(legend);
        }
        // 先获取legend的padding
        var legendPadding = getOverlappingPadding(this.layers[0], this.paddingComponents);
        var axisComponents = ComboUtil.axesLayout(this.globalOptions, this.axisInfo, legendPadding, this.layers[0], this.width, this.height, this.getCanvas());
        (_a = this.paddingComponents).push.apply(_a, axisComponents);
        _.each(axisComponents, function (axis) {
            _this.globalComponents.push({ type: 'axis', component: axis.component });
        });
        // 计算padding
        var padding = getOverlappingPadding(this.layers[0], this.paddingComponents);
        if (!this.globalOptions.xAxis.visible) {
            padding[2] += bleeding[2];
        }
        // 更新layers
        _.each(this.layers, function (layer) {
            layer.updateConfig({
                padding: padding,
            });
            layer.render();
            layer.show();
        });
        //补画坐标轴grid
        if (this.globalOptions.yAxis.grid.visible) {
            var leftAxis = axisComponents[0].component;
            var containerLayer = this.layers[0];
            var coord = containerLayer.view.geometries[0].coordinate;
            var container = containerLayer.view.backgroundGroup;
            ComboUtil.drawYGrid(leftAxis, coord, container, this.globalOptions);
        }
        this.canvas.draw();
        if (this.globalOptions.tooltip.visible) {
            var tooltip = ComboUtil.showTooltip(this.canvas, this.layers);
            this.globalComponents.push({ type: 'tooltip', component: tooltip });
        }
    };
    OverlappedComboPlot.prototype.doDestroy = function () {
        this.clearComponents();
        this.eachLayer(function (layer) {
            layer.destroy();
        });
        this.layers = [];
    };
    OverlappedComboPlot.prototype.clearComponents = function () {
        _.each(this.globalComponents, function (c) {
            if (c.type === 'legend' || c.type === 'tooltip') {
                c.component.destroy();
            }
            if (c.type === 'axis') {
                c.component.clear();
            }
        });
        this.paddingComponents = [];
        this.globalComponents = [];
    };
    OverlappedComboPlot.prototype.layerOptionsFilter = function (options) {
        var filterOptions = [];
        _.each(options, function (option) {
            if (!_.isNil(option.data) && option.data.length > 0) {
                filterOptions.push(option);
            }
        });
        return filterOptions;
    };
    return OverlappedComboPlot;
}(ComboPlot));
export default OverlappedComboPlot;
//# sourceMappingURL=overlapped.js.map