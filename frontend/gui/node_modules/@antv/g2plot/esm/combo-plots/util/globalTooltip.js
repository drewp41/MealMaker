import { each, isArray, isObject, indexOf, isNil, has, keys } from '@antv/util';
import { Tooltip, getShapeFactory } from '../../dependents';
import { getGlobalTheme } from '../../theme/global';
var TYPE_SHOW_MARKERS = ['line', 'area', 'path', 'areaStack'];
export function showTooltip(canvas, layers, tooltipCfg) {
    var tooltip = renderTooltip(layers[0], canvas);
    tooltip.init();
    canvas.on('mousemove', function (ev) {
        var tooltipItems = [];
        var point = { x: ev.x, y: ev.y };
        each(layers, function (layer) {
            var view = layer.view;
            if (view && layer.visibility) {
                //const coord = view.geometries[0].coordinate;
                //const geoms = view.geometries;
                tooltipItems.push.apply(tooltipItems, view.getTooltipItems(point));
                /*each(geoms, (geom) => {
                  const type = geom.type;
                  const dataArray = geom.dataArray;
                  if (contains(['area', 'line', 'path', 'interval'], type)) {
                    const items = getTooltipItems(point, geom, type, dataArray, coord);
                    tooltipItems.push(...items);
                  } else {s
                    const shapeContainer = geom.container;
                    const shapes = getShapeByX(shapeContainer, point.x);
                    each(shapes, (shape) => {
                      if (shape.get('visible') && shape.get('origin')) {
                        const items = geom.getTooltipItems(shape.get('origin'), null);
                        tooltipItems.push(...items);
                      }
                    });
                  }
                });*/
            }
        });
        //adjustItems(tooltipItems, ev.target, tooltipCfg);
        if (tooltipItems.length > 0) {
            tooltip.setLocation(point);
            tooltip.update({
                items: getUniqueItems(tooltipItems),
                domStyles: {
                    'g2-tooltip': {
                        opacity: 1,
                    },
                },
            });
            tooltip.show();
        }
        else if (tooltip.get('visible')) {
            tooltip.hide();
        }
    });
    return tooltip;
}
function getTooltipItems(point, geom, type, dataArray, coord) {
    var items = [];
    each(dataArray, function (data) {
        var items = geom.findItemsFromView(geom.view, point);
        var subItems = geom.getTooltipItems(point, null);
        each(subItems, function (v) {
            // tslint:disable-next-line: no-shadowed-variable
            var point = v.point;
            if (!isNil(point) && !isNil(point.x) && !isNil(point.y)) {
                var x = isArray(point.x) ? point.x[point.x.length - 1] : point.x;
                var y = isArray(point.y) ? point.y[point.y.length - 1] : point.y;
                point = coord.applyMatrix(x, y, 1);
                v.x = point[0];
                v.y = point[1];
                v.showMarker = true;
                var itemMarker = getItemMarker(geom, v.color);
                v.marker = itemMarker;
                if (indexOf(TYPE_SHOW_MARKERS, type) !== -1) {
                    items.push(v);
                }
            }
        });
        items.push.apply(items, subItems);
    });
    return items;
}
function renderTooltip(layer, canvas) {
    var tooltipTheme = getGlobalTheme().tooltip;
    var options = {
        parent: layer.canvas.get('container'),
        panelGroup: layer.view.middleGroup,
        panelRange: layer.view.coodinateBBox,
        capture: false,
        canvas: canvas,
        frontgroundGroup: layer.view.frontgroundGroup,
        theme: tooltipTheme,
        backgroundGroup: layer.view.backgroundGroup,
        items: [{ name: 0, value: 0 }],
        domStyles: {
            'g2-tooltip': {
                opacity: 0,
            },
        },
    };
    return new Tooltip.Html(options);
}
function getItemMarker(geom, color) {
    var shapeType = geom.get('shapeType') || 'point';
    var shape = geom.getDefaultValue('shape') || 'circle';
    var shapeObject = getShapeFactory(shapeType);
    var cfg = { color: color, isInPolar: false };
    var marker = shapeObject.getMarker(shape, cfg);
    return marker;
}
function getUniqueItems(items) {
    var tmp = [];
    each(items, function (item) {
        var index = indexOfArray(tmp, item);
        if (index === -1) {
            tmp.push(item);
        }
    });
    return tmp;
}
function indexOfArray(items, item) {
    var rst = -1;
    each(items, function (sub, index) {
        var isEqual = true;
        for (var key in item) {
            if (has(item, key)) {
                if (!isObject(item[key]) && item[key] !== sub[key]) {
                    isEqual = false;
                    break;
                }
            }
        }
        if (isEqual) {
            rst = index;
            return false;
        }
    });
    return rst;
}
function adjustItems(items, target, cfg) {
    if (target.get('origin')) {
        var data_1;
        if (isArray(target.get('origin'))) {
            data_1 = getDataByTitle(items[0].title, target.get('origin')).data;
        }
        else {
            data_1 = target.get('origin')._origin;
        }
        each(items, function (item) {
            if (item.point._origin !== data_1) {
                item.color = '#ccc';
            }
        });
    }
    if (cfg.sort) {
        items.sort(function (a, b) {
            return parseFloat(b.value) - parseFloat(a.value);
        });
    }
}
function getDataByTitle(title, data) {
    for (var i in data) {
        var d = data[i]._origin;
        var ks = keys(d);
        for (var j in ks) {
            var key = ks[j];
            if (d[key] === title) {
                return { data: d, key: key };
            }
        }
    }
}
function getShapeByX(container, x) {
    var shapes = [];
    var children = container.get('children');
    each(children, function (c) {
        var bbox = c.getBBox();
        if (bbox.minX < x && bbox.maxX > x) {
            shapes.push(c);
        }
    });
    return shapes;
}
//# sourceMappingURL=globalTooltip.js.map