import { filter, each, isArray, clone, has } from '@antv/util';
import BBox from '../../util/bbox';
import { getLegendShapes, getAxisComponents } from '../../util/common';
/**
 * 处理图表padding的逻辑：
 * 注册参与padding的自定义组件
 */
var PaddingController = /** @class */ (function () {
    function PaddingController(cfg) {
        this.innerPaddingComponents = [];
        this.outerPaddingComponents = [];
        this.plot = cfg.plot;
    }
    PaddingController.prototype.registerPadding = function (component, type, checkIfExist) {
        if (type === void 0) { type = 'outer'; }
        if (checkIfExist === void 0) { checkIfExist = false; }
        if (type === 'inner') {
            if (checkIfExist) {
                if (!this.innerPaddingComponents.find(function (c) { return c == component; })) {
                    this.innerPaddingComponents.push(component);
                }
            }
            else {
                this.innerPaddingComponents.push(component);
            }
        }
        else {
            if (checkIfExist) {
                if (!this.outerPaddingComponents.find(function (c) { return c == component; })) {
                    this.outerPaddingComponents.push(component);
                }
            }
            else {
                this.outerPaddingComponents.push(component);
            }
        }
    };
    /**
     * 清除已经注册的元素
     */
    PaddingController.prototype.clear = function () {
        this.innerPaddingComponents = [];
        // 一些组件是在view渲染完成之后渲染初始化的
        // TODO: afterRender的什么时候清除
        this.outerPaddingComponents = filter(this.outerPaddingComponents, function (component) { return component.afterRender; });
    };
    PaddingController.prototype.clearOuterComponents = function () {
        each(this.outerPaddingComponents, function (component) {
            if (component.afterRender) {
                component.destroy();
            }
        });
        this.outerPaddingComponents = [];
    };
    PaddingController.prototype.getPadding = function () {
        var props = this.plot.options;
        var padding = props.padding ? props.padding : this.plot.config.theme.padding;
        if (padding === 'auto') {
            return [0, 0, 0, 1];
        }
        return padding;
    };
    /** view层的padding计算 */
    PaddingController.prototype.processAutoPadding = function () {
        var padding = this._getInnerAutoPadding();
        this.plot.updateConfig({
            padding: padding,
        });
        this.plot.render();
    };
    PaddingController.prototype.processOuterPadding = function () {
        if (!this.plot.layerBBox) {
            this.plot.layerBBox = new BBox(this.plot.x, this.plot.y, this.plot.width, this.plot.height);
        }
        var viewMinX = this.plot.layerBBox.minX;
        var viewMaxX = this.plot.layerBBox.maxX;
        var viewMinY = this.plot.layerBBox.minY;
        var viewMaxY = this.plot.layerBBox.maxY;
        each(this.outerPaddingComponents, function (component) {
            var position = component.position;
            var _a = component.getBBox(), minX = _a.minX, maxX = _a.maxX, minY = _a.minY, maxY = _a.maxY;
            if (maxY >= viewMinY && maxY <= viewMaxY && position === 'top') {
                viewMinY = maxY;
            }
            if (minY >= viewMinY && minY <= viewMaxY && position === 'bottom') {
                viewMaxY = minY;
            }
            if (maxX > viewMinX && maxX <= viewMaxX && position === 'left') {
                viewMinX = maxX;
            }
            if (minX >= viewMinX && maxX <= viewMaxX && position === 'right') {
                viewMaxX = minX;
            }
        });
        return new BBox(viewMinX, viewMinY, viewMaxX - viewMinX, viewMaxY - viewMinY);
    };
    PaddingController.prototype._getInnerAutoPadding = function () {
        var props = this.plot.options;
        var view = this.plot.view;
        var viewRange = clone(view.viewBBox);
        var maxX = viewRange.maxX, maxY = viewRange.maxY;
        var bleeding = this.plot.config.theme.bleeding;
        if (isArray(bleeding)) {
            each(bleeding, function (it, index) {
                if (typeof bleeding[index] === 'function') {
                    bleeding[index] = bleeding[index](props);
                }
            });
        }
        this.plot.config.theme.legend.margin = bleeding;
        this.bleeding = clone(bleeding);
        // 参与auto padding的components: axis legend
        var components_bbox;
        if (has(this.plot.options, 'radius')) {
            components_bbox = [new BBox(0, viewRange.minY, viewRange.width, viewRange.height)];
        }
        else {
            components_bbox = [new BBox(0, 0, viewRange.width, viewRange.height)];
        }
        this._getAxis(view, components_bbox);
        var box = this._mergeBBox(components_bbox);
        this._getLegend(view, components_bbox, viewRange, this.plot.options);
        box = this._mergeBBox(components_bbox);
        // 参与auto padding的自定义组件
        var components = this.innerPaddingComponents;
        each(components, function (obj) {
            var component = obj;
            var bbox = component.getBBox();
            components_bbox.push(bbox);
        });
        box = this._mergeBBox(components_bbox);
        var padding = [
            0 - box.minY + this.bleeding[0],
            box.maxX - maxX + this.bleeding[1],
            box.maxY - maxY + this.bleeding[2],
            0 - box.minX + this.bleeding[3],
        ];
        //this.adjustAxisPadding(view, padding);
        // label、annotation等
        var panelPadding = this._getPanel(view);
        padding[0] += panelPadding[0];
        padding[1] += panelPadding[1];
        padding[2] += panelPadding[2];
        padding[3] += panelPadding[3];
        return padding;
    };
    PaddingController.prototype._getAxis = function (view, bboxes) {
        var axes = getAxisComponents(view);
        each(axes, function (axis) {
            var layoutBBox = axis.getLayoutBBox();
            bboxes.push(BBox.fromBBoxObject(layoutBBox));
        });
    };
    PaddingController.prototype._getLegend = function (view, bboxes, viewRange, options) {
        var legendContainer = getLegendShapes(view)[0];
        if (legendContainer) {
            var bbox = legendContainer.getBBox();
            if (options.legend) {
                var position = options.legend.position.split('-')[0];
                if (position === 'top') {
                    bboxes.push(new BBox(bbox.minX, -bbox.height, bbox.width, bbox.height));
                }
                else if (position === 'bottom') {
                    bboxes.push(new BBox(bbox.minX, bbox.height + viewRange.height, bbox.width, bbox.height));
                }
                else if (position === 'left') {
                    bboxes.push(new BBox(bbox.minX - bbox.width, bbox.minY, bbox.width, bbox.height));
                }
                else {
                    bboxes.push(new BBox(viewRange.maxX, bbox.minY, bbox.width, bbox.height));
                }
            }
        }
    };
    PaddingController.prototype._getPanel = function (view) {
        var groups = [];
        var geoms = view.geometries;
        each(geoms, function (geom) {
            if (geom.labelsContainer) {
                groups.push(geom.labelsContainer);
            }
        });
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        each(groups, function (group) {
            var children = group.get('children');
            children.forEach(function (child) {
                if (child.type === 'group' && child.get('children').length === 0) {
                    return;
                }
                var bbox = child.getBBox();
                if (bbox.minX < minX) {
                    minX = bbox.minX;
                }
                if (bbox.maxX > maxX) {
                    maxX = bbox.maxX;
                }
                if (bbox.minY < minY) {
                    minY = bbox.minY;
                }
                if (bbox.maxY > maxY) {
                    maxY = bbox.maxY;
                }
            });
        });
        var panelRange = view.coordinateBBox;
        //right
        var rightDist = Math.max(maxX - parseFloat(panelRange.maxX), 0);
        if (rightDist > 0) {
            var ratio = panelRange.width / (panelRange.width + rightDist);
            rightDist *= ratio;
        }
        //left
        var leftDist = Math.max(parseFloat(panelRange.minX) - minX, 0);
        if (leftDist > 0) {
            var ratio = panelRange.width / (panelRange.width + leftDist);
            leftDist *= ratio;
        }
        //top
        var topDist = Math.max(parseFloat(panelRange.minY) - minY, 0);
        if (topDist > 0) {
            var ratio = panelRange.height / (panelRange.height + topDist);
            topDist *= ratio;
        }
        //bottom
        var bottomDist = Math.max(maxY - parseFloat(panelRange.maxY), 0);
        if (bottomDist > 0) {
            var ratio = panelRange.height / (panelRange.height + bottomDist);
            bottomDist *= ratio;
        }
        return [topDist, rightDist, bottomDist, leftDist];
    };
    PaddingController.prototype._mergeBBox = function (bboxes) {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        each(bboxes, function (bbox) {
            var box = bbox;
            minX = Math.min(box.minX, minX);
            maxX = Math.max(box.maxX, maxX);
            minY = Math.min(box.minY, minY);
            maxY = Math.max(box.maxY, maxY);
        });
        return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };
        // return new BBox(minX, minY, maxX - minX, maxY - minY);
    };
    PaddingController.prototype._adjustLegend = function (legend, view, box) {
        var position = legend.get('position').split('-');
        var container = legend.get('container');
        var bbox = container.getBBox();
        var _a = view.viewBBox, width = _a.width, maxY = _a.maxY, minY = _a.minY;
        if (position[0] === 'right') {
            container.move(width, minY);
        }
        if (position[0] === 'left') {
            container.move(box.minX - bbox.width, minY);
        }
        if (position[0] === 'top') {
            container.move(0, box.minY - bbox.height);
        }
        if (position[0] === 'bottom') {
            container.move(0, Math.max(maxY, box.maxY));
        }
    };
    PaddingController.prototype._getLegendInnerPadding = function (legend) {
        var innerPadding = this.plot.theme.legend.innerPadding;
        var position = legend.get('position').split('-');
        if (position[0] === 'top') {
            return [innerPadding[0], 0, 0, 0];
        }
        if (position[0] === 'bottom') {
            return [0, 0, innerPadding[2], 0];
        }
        if (position[0] === 'left') {
            return [0, 0, 0, innerPadding[3]];
        }
        if (position[0] === 'right') {
            return [0, innerPadding[1], 0, 0];
        }
    };
    PaddingController.prototype._mergeBleeding = function (source) {
        var target = this.bleeding;
        if (source.length !== target.length) {
            return;
        }
        for (var i = 0; i < source.length; i++) {
            target[i] += source[i];
        }
    };
    return PaddingController;
}());
export default PaddingController;
//# sourceMappingURL=padding.js.map